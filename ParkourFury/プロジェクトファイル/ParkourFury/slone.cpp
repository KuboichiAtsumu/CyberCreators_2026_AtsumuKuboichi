//==============================================================================================================================================
//
// 坂道に関する処理
// Author : Atsumu Kuboichi
//
//==============================================================================================================================================

//===========================================================================================================
// ヘッダーインクルード
//===========================================================================================================
#include "slone.h"

//===========================================================================================================
// コンストラクタ
//===========================================================================================================
CSlone::CSlone() : CBlock()
{
}

//===========================================================================================================
// デストラクタ
//===========================================================================================================
CSlone::~CSlone()
{
}

//===========================================================================================================
// 初期化処理
//===========================================================================================================
HRESULT CSlone::Init()
{
	//基底クラス初期化処理
	if (FAILED(CBlock::Init()))
	{
		return E_FAIL;
	}

	return S_OK;
}

//===========================================================================================================
// 終了処理
//===========================================================================================================
void CSlone::Uninit()
{
	//基底クラス終了処理
	CBlock::Uninit();
}

//===========================================================================================================
// 解放処理
//===========================================================================================================
void CSlone::Release()
{
	//基底クラス解放処理
	CBlock::Release();
}

//===========================================================================================================
// 更新処理
//===========================================================================================================
void CSlone::Update()
{
	//基底クラス更新処理
	CBlock::Update();
}

//===========================================================================================================
// 描画処理
//===========================================================================================================
void CSlone::Draw()
{
	//エディタモードの場合
	if (CManager::GetInstance()->GetScene()->GetSceneState() == CScene::SCENE::EDIT_3D)
	{//描画せずに処理を抜ける
		return;
	}

	//基底クラス描画処理
	CBlock::Draw();
}

//===========================================================================================================
// 当たり判定
//===========================================================================================================
CBlock::CollisionFlag CSlone::Collision(CollisionParam& aParam)
{
	//情報を取得
	CollisionFlag aFlag = {};
	D3DXVECTOR3 Pos = GetPos();//座標
	D3DXVECTOR3 Size = GetSize();//サイズ

	//範囲内にいる場合
	if ((aParam.pos.x + aParam.size.x * 0.5f > Pos.x - Size.x * 0.5f
		&& aParam.pos.x - aParam.size.x * 0.5f < Pos.x + Size.x * 0.5f)
		&& (aParam.pos.z + aParam.size.z * 0.5f > Pos.z - Size.z * 0.5f
			&& aParam.pos.z - aParam.size.z * 0.5f < Pos.z + Size.z * 0.5f)
		&& (aParam.pos.y <= Pos.y + Size.y * 0.5f
			&& aParam.pos.y >= Pos.y - Size.y * 0.5f))
	{
		//ローカル変数宣言
		D3DXVECTOR3 vtxMax = { 0.0f, 0.0f, 0.0f };//最大頂点座標
		D3DXVECTOR3 vtxMin = { 0.0f, 0.0f, 0.0f };//最小頂点座標
		D3DXVECTOR3 Normal = { 0.0f, 0.0f, 0.0f };//垂直ベクトル
		D3DXVECTOR3 DirectionVec = { 0.0f, 0.0f, 0.0f };//方向ベクトル
		float fDot = 0.0f;//内積

		//XY線上にいる場合
		if (GetStandLine() == CObjectX::STAND_LINE::XY)
		{
			//頂点を設定
			vtxMax = { GetVtxMax().x, Pos.y + Size.y * 0.5f, 0.0f };
			vtxMin = { GetVtxMin().x, Pos.y - Size.y * 0.5f, 0.0f };

			//垂直ベクトルを求める
			Normal = SEGMENT_XY(vtxMax.x, vtxMax.y, vtxMin.x, vtxMin.y);

			//頂点からの方向ベクトルを求める
			DirectionVec = aParam.pos - vtxMax;

			//内積を求める
			fDot = D3DXVec3Dot(&Normal, &DirectionVec);

			//内積が0の場合
			if ((fDot >= 0.0f && vtxMin.x < vtxMax.x)
				|| (fDot <= 0.0f && vtxMax.x < vtxMin.x))
			{
				//プレイヤーの位置を坂道に合わせる
				aParam.pos.y = vtxMax.y + (-Normal.x * DirectionVec.x - Normal.z * DirectionVec.z) / Normal.y;

				//上側の当たり判定をtrueにする
				aFlag.Y_UP = true;

				//自分自身のタイプを保存
				aParam.type = GetBlockType();
			}
		}

		//YZ線上にいる場合
		else if (GetStandLine() == CObjectX::STAND_LINE::YZ)
		{
			//頂点を設定
			vtxMax = { 0.0f, Pos.y + Size.y * 0.5f, GetVtxMin().z };
			vtxMin = { 0.0f, Pos.y - Size.y * 0.5f, GetVtxMax().z };

			//垂直ベクトルを求める
			Normal = SEGMENT_YZ(vtxMax.y, vtxMax.z, vtxMin.y, vtxMin.z);

			//頂点からの方向ベクトルを求める
			DirectionVec = aParam.pos - vtxMax;

			//内積を求める
			fDot = D3DXVec3Dot(&Normal, &DirectionVec);

			//内積が0の場合
			if ((fDot >= 0.0f && vtxMin.z < vtxMax.z)
				|| (fDot <= 0.0f && vtxMax.z < vtxMin.z))
			{
				//プレイヤーの位置を坂道に合わせる
				aParam.pos.y = vtxMax.y + (-Normal.x * DirectionVec.x - Normal.z * DirectionVec.z) / Normal.y;

				//上側の当たり判定をtrueにする
				aFlag.Y_UP = true;

				//自分自身のタイプを保存
				aParam.type = GetBlockType();
			}
		}
	}
	
	return aFlag;
}
