//==============================================================================================================================================
//
// ボス攻撃に関する処理
// Author : Atsumu Kuboichi
//
//==============================================================================================================================================

//===========================================================================================================
// ヘッダーインクルード
//===========================================================================================================
#include "bossattack.h"

//===========================================================================================================
// コンストラクタ
//===========================================================================================================
CBossAttack::CBossAttack(int nPriority) : CObjectX(nPriority)
{
}

//===========================================================================================================
// デストラクタ
//===========================================================================================================
CBossAttack::~CBossAttack()
{
}

//===========================================================================================================
// 初期化処理
//===========================================================================================================
HRESULT CBossAttack::Init()
{
	//モデル生成
	CXfile* pModel = CXfile::GetInstance();//インスタンスを取得
	BindModel(pModel->GetAddress(CTag::TAG::BOSS_ATTACK, 1));//設定
	SetSize();//サイズ設定

	//基底クラス初期化処理
	if (FAILED(CObjectX::Init()))
	{
		return E_FAIL;
	}

	return S_OK;
}

//===========================================================================================================
// 終了処理
//===========================================================================================================
void CBossAttack::Uninit()
{
	//基底クラス終了処理
	CObjectX::Uninit();
}

//===========================================================================================================
// 解放処理
//===========================================================================================================
void CBossAttack::Release()
{
	//基底クラス解放処理
	CObjectX::Release();
}

//===========================================================================================================
// 更新処理
//===========================================================================================================
void CBossAttack::Update()
{
	//基底クラス更新処理
	CObjectX::Update();

	//移動処理
	Move();

	//回転処理
	Rotation();
}

//===========================================================================================================
// 移動処理
//===========================================================================================================
void CBossAttack::Move()
{
	//座標情報を取得
	D3DXVECTOR3 pos = GetPos();

	//移動量を加算
	pos += GetMove();

	//目標の位置までの差分を求める
	D3DXVECTOR3 Difference = m_TargetPos - pos;

	//目標の位置に達した場合
	if (abs(Difference.x) < 1.0f && 
		abs(Difference.y) < 1.0f &&
		abs(Difference.z) < 1.0f)
	{
		//終了処理
		Uninit();
	}

	//座標を設定
	SetPos(pos);
}

//===========================================================================================================
// 回転処理
//===========================================================================================================
void CBossAttack::Rotation()
{
	//ローカル変数宣言
	D3DXVECTOR3 rot = GetRot();//角度情報

	//回転処理
	rot.x += ROTATION_SPEED;

	//角度補正
	CorrectionRot(rot.x);

	//更新された角度情報設定
	SetRot(rot);
}

//===========================================================================================================
// 描画処理
//===========================================================================================================
void CBossAttack::Draw()
{
	//エディタモードの場合
	if (CManager::GetInstance()->GetScene()->GetSceneState() == CScene::SCENE::EDIT_3D)
	{//描画せずに処理を抜ける
		return;
	}

	//Xファイルのオブジェクト描画処理
	CObjectX::Draw();
}

//===========================================================================================================
// 生成処理
//===========================================================================================================
CBossAttack* CBossAttack::Create(const D3DXVECTOR3& pos, const D3DXVECTOR3& TargetPos, const D3DXVECTOR3& rot, const D3DXVECTOR3& move)
{
	//メモリを動的確保
	CBossAttack* pBossAttack = NEW CBossAttack(static_cast<int>(Category::BOSS_ATTACK));

	//ボス攻撃の情報が存在する場合
	if (pBossAttack != nullptr)
	{
		//パラメータ設定
		pBossAttack->SetPos(pos);//座標
		pBossAttack->m_TargetPos = TargetPos;//目標の座標
		pBossAttack->SetRot(rot);//角度
		pBossAttack->SetMove(move);//移動量

		//初期化処理
		pBossAttack->Init();
	}

	return pBossAttack;
}

//===========================================================================================================
// 当たり判定
//===========================================================================================================
bool CBossAttack::Collision(CollisionParam& aParam)
{
	//列挙型定義
	enum class Vec3
	{
		X = 0,
		Y,
		Z,
		MAX
	};

	//ローカル変数宣言
	bool bCollision[static_cast<int>(Vec3::MAX)] = {};//各軸の当たり判定フラグ

	//各軸の番号をint型で保存
	int X = static_cast<int>(Vec3::X);
	int Y = static_cast<int>(Vec3::Y);
	int Z = static_cast<int>(Vec3::Z);

	//現在立っている線上情報を取得
	STAND_LINE Line = GetStandLine();

	//XY線上にいる場合
	if (Line == STAND_LINE::XY)
	{
		//X軸から判定
		bCollision[X] = Collision_X(aParam);
		bCollision[Z] = Collision_Z(aParam);
	}
	//YZ線上にいる場合
	else if (Line == STAND_LINE::YZ)
	{
		//Z軸から判定
		bCollision[Z] = Collision_Z(aParam);
		bCollision[X] = Collision_X(aParam);
	}

	//Y軸の判定
	bCollision[Y] = Collision_Y(aParam);

	//全ての軸の判定がtrueの場合
	if (bCollision[X] && bCollision[Y] && bCollision[Z])
	{
		return true;
	}
	//いずれかの軸の判定がfalseの場合
	else
	{
		return false;
	}
}

//===========================================================================================================
// X軸の当たり判定
//===========================================================================================================
bool CBossAttack::Collision_X(CollisionParam& aParam)
{
	//ローカル変数宣言
	D3DXVECTOR3 Pos = GetPos();//座標情報
	D3DXVECTOR3 Size = GetSize();//サイズ情報

	//X軸が重なっている場合
	if (aParam.pos.x + aParam.size.x * 0.5f >= Pos.x - Size.x * 0.5f
		&& aParam.pos.x - aParam.size.x * 0.5f <= Pos.x + Size.x * 0.5f)
	{
		return true;
	}
	//X軸が重なっていない場合
	else
	{
		return false;
	}
}

//===========================================================================================================
// Y軸の当たり判定
//===========================================================================================================
bool CBossAttack::Collision_Y(CollisionParam& aParam)
{
	//ローカル変数宣言
	D3DXVECTOR3 Pos = GetPos();//座標情報
	D3DXVECTOR3 Size = GetSize();//サイズ情報

	//Y軸が重なっている場合
	if (aParam.pos.y + aParam.size.y * 0.5f >= Pos.y - Size.y * 0.5f
		&& aParam.pos.y - aParam.size.y * 0.5f <= Pos.y + Size.y * 0.5f)
	{
		return true;
	}
	//Y軸が重なっていない場合
	else
	{
		return false;
	}
}

//===========================================================================================================
// Z軸の当たり判定
//===========================================================================================================
bool CBossAttack::Collision_Z(CollisionParam& aParam)
{
	//ローカル変数宣言
	D3DXVECTOR3 Pos = GetPos();//座標情報
	D3DXVECTOR3 Size = GetSize();//サイズ情報

	//Z軸が重なっている場合
	if (aParam.pos.z + aParam.size.z * 0.5f >= Pos.z - Size.z * 0.5f
		&& aParam.pos.z - aParam.size.z * 0.5f <= Pos.z + Size.z * 0.5f)
	{
		return true;
	}
	//Z軸が重なっていない場合
	else
	{
		return false;
	}
}
